!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.ensemble=e():t.ensemble=e()}(self,(()=>(()=>{"use strict";var t={7:t=>{var e,r="object"==typeof Reflect?Reflect:null,n=r&&"function"==typeof r.apply?r.apply:function(t,e,r){return Function.prototype.apply.call(t,e,r)};e=r&&"function"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var s=Number.isNaN||function(t){return t!=t};function i(){i.init.call(this)}t.exports=i,t.exports.once=function(t,e){return new Promise((function(r,n){function s(r){t.removeListener(e,i),n(r)}function i(){"function"==typeof t.removeListener&&t.removeListener("error",s),r([].slice.call(arguments))}d(t,e,i,{once:!0}),"error"!==e&&function(t,e){"function"==typeof t.on&&d(t,"error",e,{once:!0})}(t,s)}))},i.EventEmitter=i,i.prototype._events=void 0,i.prototype._eventsCount=0,i.prototype._maxListeners=void 0;var o=10;function a(t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t)}function c(t){return void 0===t._maxListeners?i.defaultMaxListeners:t._maxListeners}function h(t,e,r,n){var s,i,o,h;if(a(r),void 0===(i=t._events)?(i=t._events=Object.create(null),t._eventsCount=0):(void 0!==i.newListener&&(t.emit("newListener",e,r.listener?r.listener:r),i=t._events),o=i[e]),void 0===o)o=i[e]=r,++t._eventsCount;else if("function"==typeof o?o=i[e]=n?[r,o]:[o,r]:n?o.unshift(r):o.push(r),(s=c(t))>0&&o.length>s&&!o.warned){o.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=t,u.type=e,u.count=o.length,h=u,console&&console.warn&&console.warn(h)}return t}function u(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function l(t,e,r){var n={fired:!1,wrapFn:void 0,target:t,type:e,listener:r},s=u.bind(n);return s.listener=r,n.wrapFn=s,s}function f(t,e,r){var n=t._events;if(void 0===n)return[];var s=n[e];return void 0===s?[]:"function"==typeof s?r?[s.listener||s]:[s]:r?function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(s):y(s,s.length)}function p(t){var e=this._events;if(void 0!==e){var r=e[t];if("function"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function y(t,e){for(var r=new Array(e),n=0;n<e;++n)r[n]=t[n];return r}function d(t,e,r,n){if("function"==typeof t.on)n.once?t.once(e,r):t.on(e,r);else{if("function"!=typeof t.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof t);t.addEventListener(e,(function s(i){n.once&&t.removeEventListener(e,s),r(i)}))}}Object.defineProperty(i,"defaultMaxListeners",{enumerable:!0,get:function(){return o},set:function(t){if("number"!=typeof t||t<0||s(t))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+t+".");o=t}}),i.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},i.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||s(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this},i.prototype.getMaxListeners=function(){return c(this)},i.prototype.emit=function(t){for(var e=[],r=1;r<arguments.length;r++)e.push(arguments[r]);var s="error"===t,i=this._events;if(void 0!==i)s=s&&void 0===i.error;else if(!s)return!1;if(s){var o;if(e.length>0&&(o=e[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var c=i[t];if(void 0===c)return!1;if("function"==typeof c)n(c,this,e);else{var h=c.length,u=y(c,h);for(r=0;r<h;++r)n(u[r],this,e)}return!0},i.prototype.addListener=function(t,e){return h(this,t,e,!1)},i.prototype.on=i.prototype.addListener,i.prototype.prependListener=function(t,e){return h(this,t,e,!0)},i.prototype.once=function(t,e){return a(e),this.on(t,l(this,t,e)),this},i.prototype.prependOnceListener=function(t,e){return a(e),this.prependListener(t,l(this,t,e)),this},i.prototype.removeListener=function(t,e){var r,n,s,i,o;if(a(e),void 0===(n=this._events))return this;if(void 0===(r=n[t]))return this;if(r===e||r.listener===e)0===--this._eventsCount?this._events=Object.create(null):(delete n[t],n.removeListener&&this.emit("removeListener",t,r.listener||e));else if("function"!=typeof r){for(s=-1,i=r.length-1;i>=0;i--)if(r[i]===e||r[i].listener===e){o=r[i].listener,s=i;break}if(s<0)return this;0===s?r.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(r,s),1===r.length&&(n[t]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",t,o||e)}return this},i.prototype.off=i.prototype.removeListener,i.prototype.removeAllListeners=function(t){var e,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[t]&&(0===--this._eventsCount?this._events=Object.create(null):delete r[t]),this;if(0===arguments.length){var s,i=Object.keys(r);for(n=0;n<i.length;++n)"removeListener"!==(s=i[n])&&this.removeAllListeners(s);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(e=r[t]))this.removeListener(t,e);else if(void 0!==e)for(n=e.length-1;n>=0;n--)this.removeListener(t,e[n]);return this},i.prototype.listeners=function(t){return f(this,t,!0)},i.prototype.rawListeners=function(t){return f(this,t,!1)},i.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):p.call(t,e)},i.prototype.listenerCount=p,i.prototype.eventNames=function(){return this._eventsCount>0?e(this._events):[]}}},e={};function r(n){var s=e[n];if(void 0!==s)return s.exports;var i=e[n]={exports:{}};return t[n](i,i.exports,r),i.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};r.r(n),r.d(n,{Cue:()=>h,EmitterSecondo:()=>v,Ensemble:()=>c,Event:()=>i,IntersectionObserverSecondo:()=>y,MutationObserverSecondo:()=>f,ObserverSecondo:()=>l,Ostinato:()=>S,Player:()=>o,ResizeObserverSecondo:()=>d,Secondo:()=>u,Solo:()=>T,Ticket:()=>I});var s=r(7);class i{constructor(t,e,r=[],n=void 0){this.emitter=t,this.type=e,this.args=Array.isArray(r)?r:[r],this.source=n,this.timestamp=Date.now()}wasEmittedBy(t){return this.emitter===t||this.source?.wasEmittedBy(t)}get propagationPath(){const t=[];let e=this;for(;e;)t.unshift(e.emitter),e=e.source;return t}get origin(){return this.source?.origin??this}}class o extends s.EventEmitter{playing;name;ensemble;constructor(t){super(),this.playing=!1,this.name=t,this.ensemble=void 0}play(){return this.playing=!0,this}pause(){return this.playing=!1,this}let(t,e){const r=this[t];return r===e||(this[t]=e,this.emit(new a(this,t,r,e))),this}emit(t,...e){const r=new i(this,t,e);if(super.emit(t,r),this.ensemble){const e=new i(this.ensemble,t,[],r);this.ensemble.emit(t,e)}return this}}class a extends i{constructor(t,e,r,n){super(t,"propertychange",[e,r,n])}get propertyName(){return this.args[0]}get oldValue(){return this.args[1]}get newValue(){return this.args[2]}}class c extends o{players;constructor(){super(),this.players=new Map}add(t,e){if(this.players.has(t))throw new Error(`A Player with the name "${t}" is already in this Ensemble.`);return this.players.set(t,e),e.let("name",t),e.let("ensemble",this),this}get(t,e=!1){let r=this.players.get(t);return!r&&e&&(r=new c,this.playing&&r.play(),this.add(t,r)),r}has(t){return this.players.has(t)}remove(t){const e=this.players.get(t);return!!e&&(e.let("ensemble",void 0),e.let("name",void 0),this.players.delete(t))}rotate(t=void 0){if(!t&&this.players.size>0){const e=this.players.values().next().value;t=e?.name}const e=this.get(t);return e&&(this.remove(t),this.add(t,e)),e}sort(t,e=void 0){const r=Array.from(this.players.entries()).sort(t),n=void 0!==e?r.splice(e):[];this.players.clear();for(const[t,e]of r)this.players.set(t,e);return n}descendants(t=!1){const e=[];for(const r of this.players.values())r instanceof c?(t&&e.push(r),e.push(...r.descendants(t))):e.push(r);return e}play(){if(!this.playing){for(const t of this.players.values())"function"!=typeof t.play||t.playing||t.play();this.let("playing",!0)}}pause(){if(this.playing){for(const t of this.players.values())"function"==typeof t.pause&&t.playing&&t.pause();this.let("playing",!1)}}}class h extends o{_emitter;_event;_rawListener;_boundListener;_opts;_attached;constructor(t,e,r,n={}){if(super(),"string"!=typeof e)throw new TypeError("event must be a string");if("function"!=typeof r)throw new TypeError("listener must be a function");this._emitter=t,this._event=e,this._rawListener=r,this._boundListener=r.bind(this),this._opts=n,this._attached=!1}get emitter(){return this._emitter}get event(){return this._event}get boundListener(){return this._boundListener}get attached(){return this._attached}set attached(t){this._attached=t}play(){if(this.attached)return;const{emitter:t,event:e,boundListener:r,_opts:n}=this;n.prepend&&"function"==typeof t.prependListener?t.prependListener(e,r):h.addListener(t,e,r,n),this.attached=!0}pause(){if(!this.attached)return;const{emitter:t,event:e,boundListener:r,_opts:n}=this;h.removeListener(t,e,r,n),this.attached=!1}promise(t=1e3,e=t=>void 0!==t){if("number"!=typeof t||isNaN(t))throw new TypeError("timeoutMillis must be a number");return new Promise(((r,n)=>{let s;const i=(...t)=>{try{const n=this._rawListener(...t);if(!e(n))return;h.removeListener(this._emitter,this._event,i,this._opts),clearTimeout(s),r(n)}catch(t){h.removeListener(this._emitter,this._event,i,this._opts),clearTimeout(s),n(t)}};h.addListener(this._emitter,this._event,i,this._opts),t>0&&(s=setTimeout((()=>{h.removeListener(this._emitter,this._event,i,this._opts),n(new Error(`Timeout waiting for event '${this.event}'`))}),t))}))}static addListener(t,e,r,n={}){if("function"==typeof t.addEventListener)t.addEventListener(e,r,n);else if("function"==typeof t.prependListener&&n.prepend)t.prependListener(e,r);else if("function"==typeof t.on)t.on(e,r);else{if("function"!=typeof t.addListener)throw new Error("Unsupported emitter interface for addListener");t.addListener(e,r)}}static removeListener(t,e,r,n={}){if("function"==typeof t.removeEventListener)t.removeEventListener(e,r,n);else if("function"==typeof t.off)t.off(e,r);else{if("function"!=typeof t.removeListener)throw new Error("Unsupported emitter interface for removeListener");t.removeListener(e,r)}}}class u extends o{constructor(t){super(),this.primo=t}}class l extends u{constructor(t,e={}){super(),this.observed=Array.isArray(t)?t:[t],this.opts=e,this.primo=null,this.playing=!1}get observer(){return this.primo}instantiateObserver(){throw new Error("instantiateObserver() must be implemented by subclass")}connectObserver(){this.primo&&this.observed.forEach((t=>this.primo.observe?.(t,this.opts)))}disconnectObserver(){this.primo&&(this.primo.disconnect?.(),this.observed.forEach((t=>this.primo.unobserve?.(t))))}play(){if(!this.observed.length)throw new Error("No target nodes specified");this.observer||this.instantiateObserver(),this.connectObserver(),this.playing=!0}pause(){this.disconnectObserver(),this.playing=!1}}class f extends l{instantiateObserver(){this.primo=new MutationObserver((t=>{t.forEach((t=>this.emit("mutation",new p(this,t))))}))}}class p extends i{constructor(t,e){super(t,"mutation",[],e)}}class y extends l{constructor(t,e={}){super(t,e)}instantiateObserver(){this.primo=new IntersectionObserver((t=>{t.forEach((t=>this.emit("intersection",new IntersectionObserverEntry(this,t))))}),this.opts)}}class d extends l{instantiateObserver(){this.primo=new ResizeObserver((t=>{t.forEach((t=>this.emit("resize",new m(this,t))))}))}}class m extends i{constructor(t,e){super(t,"resize",[],e)}}class v extends u{events;subTypeMapper;_eventHandlers;_opts;constructor(t,e,r=(t,...e)=>[t],n={}){super(t),this.events=e,this.subTypeMapper=r,this._opts=n,this._eventHandlers=e.map((t=>this.propagate.bind(this,t)))}play(){let t=0;for(const e of this.events)h.addListener(this.primo,e,this._eventHandlers[t++],this._opts);this.playing=!0}pause(){let t=0;for(const e of this.events)h.removeListener(this.primo,e,this._eventHandlers[t++],this._opts);this.playing=!1}propagate(t,...e){const r=this.subTypeMapper(t,...e),n=new i(this.primo,t,e);for(const t of r){const e=new i(this,t,[],n);this.emit(t,e)}return this}}class w{constructor(t=void 0,e=void 0,r={}){this._parent=t,this._name=e,this._children=r}get parent(){return this._parent}set parent(t){this._parent=t}get name(){return this._name}let(t,e){return this[t]=e,this}letChild(t,e){return this._children[t]=e,e.parent=this,e._name=t,this}get(...t){return this.ancestors().which((e=>t.every((t=>void 0!==e[t])))).then((e=>e[t[0]])).what()}getChild(...t){let e=this;for(const r of t)if(e=e?._children?.[r],!e)break;return e}resolve(t){return"string"==typeof t?this.get(t):t}forget(t){return delete this[t],this}isLeaf(){return void 0===this.children().what()}isRoot(){return void 0===this.parent}children(){return x.as(Object.values(this._children))}root(){return this.parent?this.parent.root():this}ancestors(){return x.along(this,(t=>t.parent))}}class b extends w{constructor(t=void 0,e=void 0){super(t,void 0),this._last=e,this._length=t?t._length+1:void 0!==e?1:0}static of(...t){return(new b).along(t)}get prev(){return this._parent}get last(){return this._last}get length(){return this._length}let(t,e){throw new Error("A Path is immutable!")}letChild(t,e){throw new Error("A Path is immutable!")}forget(t){throw new Error("A Path is immutable!")}isEmpty(){return 0==this._length}add(t){return new b(0<this.length?this:void 0,t)}along(t){let e=this;for(let r of t)e=e.add(r);return e}across(t){const e=this,r=new x;return r[Symbol.iterator]=function*(){for(let r of t)yield e.add(r)},r}toArray(t=this.length,e=t=>t){const r=new Array(t);let n=this;for(;0<t;)r[t-1]=e(n.last),n=n.prev,t--;return r}}class g{[Symbol.asyncIterator](){throw"abstract method!"}static of(...t){const e=new g;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},e}static as(t){let e;return void 0===t?g.of():t instanceof g?t:(t[Symbol.iterator]||t[Symbol.asyncIterator]?(e=new g,e[Symbol.asyncIterator]=async function*(){for(const e of t)yield e}):(e=new g,e[Symbol.asyncIterator]=async function*(){yield await t}),e)}async toArray(){const t=[];for await(const e of this)t.push(e);return t}async equals(t){return g.equal(this,t)}static along(t,e){const r=new g;return r[Symbol.asyncIterator]=async function*(){let r=t;for(;null!=r;)yield r,r=await e(r)},r}static async equal(t,e){if("string"==typeof t||!x.isIterable(t)&&!g.isAsyncIterable(t)||"string"==typeof e||!x.isIterable(e)&&!g.isAsyncIterable(e))return t===e;{const r=g.as(t)[Symbol.asyncIterator](),n=g.as(e)[Symbol.asyncIterator]();for(;;){const t=await r.next(),e=await n.next();if(t.done||e.done)return t.done===e.done;if(!await g.equal(t.value,e.value))return!1}}}static isAsyncIterable(t){return null!=t&&"function"==typeof t[Symbol.asyncIterator]}if(t=t=>void 0!==t){const e=this,r=new g;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)await t(n,r++)&&(yield n)},r}sthen(t){const e=this,r=new g;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)yield await t(n,r++)},r}else(t=void 0){return void 0===t?g.else(this):g.else([this,g.as(t)])}static else(t){const e=new g;return e[Symbol.asyncIterator]=async function*(){for await(const e of g.as(t)){const t=g.as(e);for await(const e of t)yield e}},e}which(t){return this.if(t)}when(t,e=!0,r=e){return g.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},g.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const s=new g;return s[Symbol.asyncIterator]=r?async function*(){let r=0,s=!1;for await(const i of t)s?yield i:await e(i,r)&&(s=!0,n&&(yield i)),r++}:async function*(){let r=0,s=!1;for await(const i of t){if(s)break;await e(i,r)?(s=!0,n&&(yield i)):yield i,r++}},s}match(t=void 0){return void 0===t?g.match(this):g.match(this,g.as(t))}static match(...t){const e=new g,r=t.map((t=>g.as(t)));return e[Symbol.asyncIterator]=async function*(){const t=r.map((t=>t[Symbol.asyncIterator]()));for(;;){const e=await Promise.all(t.map((t=>t.next())));if(e.some((t=>t.done)))break;yield e.map((t=>t.value))}},e}each(t=void 0){if(void 0===t)return g.each(...this);const e=this,r=new g;return r[Symbol.asyncIterator]=async function*(){for await(const r of e)for await(const e of g.as(t))yield[r,e]},r}static each(...t){const e=t.map((t=>g.as(t)));return O.as((t=>{if(t.length>=e.length)return g.of();const r=e[t.length],n=new g;return n[Symbol.asyncIterator]=async function*(){for await(const e of r)yield t.add(e)},n}))}self(){return g.self(this)}static self(t){const e=g.as(t),r=new g;return r[Symbol.asyncIterator]=async function*(){for(;;)yield e},r}async what(t,e){return g.what(this,t,e)}static async what(t,e,r){const n=g.as(t);if(e){let t=void 0!==r;for await(const s of n)t?r=await e(r,s):(r=s,t=!0);return r}for await(const t of n)return t}}class _{static matches(t,e){if("function"==typeof e)try{return e(t)}catch(t){return!1}if(null==t)return!1;if(t===e)return!0;if(t instanceof Error)return this.matches(t.constructor.name,e)||this.matches(t.statusCode,e)||this.matches(t.message,e);if("string"==typeof t){if("string"==typeof e)return t.includes(e);if(e instanceof RegExp)return e.test(t)}return!1}}class L extends Error{constructor(t,e="Operation timed out",r){super(e),this.millis=t,this.name=this.constructor.name,r&&(this.cause=r)}}class E{static of(...t){const e=t.slice(0,-1),r=t.at(-1);return E.as((async(...t)=>await g.equal(e,t)?r:void 0))}static as(t){if(t instanceof E)return t;if("function"!=typeof t){const e=t;t=async()=>e}const e=async(...e)=>await t(...e);return Object.setPrototypeOf(e,E.prototype),e.what=t.bind(e),e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=async t=>void 0!==t,e=void 0){return E.retype(E.if(t,this,e),this)}static if(t,e,r=void 0){return E.as((async(...n)=>{if(await t(...n))return await e(...n);throw r}))}sthen(...t){return E.retype(E.sthen(this,...t),this)}static sthen(...t){return E.as((async e=>{let r=e;for(let e of t)r=await e(r);return r}))}else(t,e=void 0){return t=E.as(t),E.retype((async(...r)=>{let n;try{n=await this(...r)}catch(n){if(!e||_.matches(n,e))return await t(...r,n);throw n}return void 0===n?await t(...r):n}),this)}which(t=async t=>void 0!==t,e=void 0){return E.retype(E.which(this,t,e),this)}static which(t,e=async t=>void 0!==t,r=void 0){return E.as((async(...n)=>{const s=await t(...n);if(await e(s,...n))return s;if(void 0!==r)throw r}))}when(t,e,r,n=void 0,s=!0){return E.when(t,this,e,r,n,s)}static when(t,e,r,n,s,i=!0){const o=E.as((async(...o)=>(i||e(...o),new Promise(((o,a)=>{let c;const h=async(...n)=>{try{await t(...n,r)&&(u(),e.stopped=!i,i?o(await e(...n,r)):o())}catch(t){u(),a(t)}},u=()=>{c&&clearTimeout(c),"function"==typeof r.off?r.off(n,h):"function"==typeof r.removeEventListener&&r.removeEventListener(n,h)};if("function"==typeof r.on)r.on(n,h);else{if("function"!=typeof r.addEventListener)throw new Error("Unsupported emitter type");r.addEventListener(n,h)}s>0&&(c=setTimeout((()=>{u(),a(new L(`Event "${n}" timed out after ${s}ms`))}),s))})))));return Object.defineProperty(o,"stopped",{get:()=>e.stopped,set:t=>e.stopped=t}),o}match(...t){return E.retype(E.match(this,...t),this)}static match(...t){const e=t.length<2?async e=>[e,await t[0](e)]:async e=>{const r=[];for(let n of t)r.push(await n(e));return r};return E.as(e)}each(t){return E.retype((async(...e)=>await g.as(await this(...e)).which().sthen(t).which().else().toArray()),this)}static each(...t){return E.as((async e=>{const r=e instanceof b?e:b.of(e);return r.length>t.length?x.of():r.across(await g.as(await E.as(t[r.length-1])(r.last)).which().toArray()).which()}))}self(...t){return E.retype(E.self(this,...t),this)}static self(t,...e){let r;if(0===e.length)return r=async e=>e.across(await g.as(await t(e.last)).which().toArray()),E.as(r);if("number"!=typeof e[0]){const[r,n]=e;return E.nominal(t,r,n)}if(1===e.length)return E.within(e[0],t);if(2===e.length){const[r,n]=e;return E.partial(t,r,n)}return E.retry(t,...e)}static partial(t,e,r){return E.as((async(...n)=>t(...n.slice(0,e),r,...n.slice(e))))}static nominal(t,e,r){let n;return n=void 0===e?async(...e)=>{const n=await t(...e);if(void 0===n)return;const s={};return s[r]=n,s}:async n=>{const s=await g.as("string"==typeof e?[e]:e).sthen((t=>"string"==typeof t?n[t]:t)).toArray(),i=await("string"==typeof t?n[t]:t)(...s);return void 0!==r?(n[r]=i,n):i},E.as(n)}static within(t,e,r=new L(`Operation timed out after ${t}ms`)){return E.as((async n=>{let s;try{return await Promise.race([e(n),new Promise(((e,n)=>{s=setTimeout((()=>n(r)),t)}))])}finally{clearTimeout(s)}}))}static retry(t,e=1/0,r=100,n=1,s=1/0){let i=!1;const o=E.as((o=>{let a=0,c=null;return new Promise(((h,u)=>{const l=async()=>{if(i)return u(new Error("Retry stopped by user"));try{const e=await t(o);h(e)}catch(t){if(c=t,a++,a<e&&!i){const t=Math.min(r*n**(a-1),s);setTimeout(l,t)}else u(i?new Error("Retry stopped by user"):c)}};l()}))}));return Object.defineProperty(o,"stopped",{get:()=>i,set:t=>{i=Boolean(t)}}),o}}class O{static of(...t){const e=t.slice(0,-1),r=t.at(-1);return O.as(((...t)=>x.equal(e,t)?r:void 0))}static as(t){if(t instanceof O)return t;if("function"!=typeof t){const e=t;t=()=>e}const e=(...e)=>t(...e);return Object.setPrototypeOf(e,O.prototype),e.what=t.bind(e),e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=t=>void 0!==t,e=void 0){return O.retype(O.if(t,this,e),this)}static if(t,e,r=void 0){return O.as(((...n)=>{if(t(...n))return e(...n);if(void 0!==r)throw r}))}sthen(t){return O.retype(O.sthen(this,t),this)}static sthen(...t){return O.as((e=>{let r=e;for(let e of t)r=e(r);return r}))}else(t,e){return t=O.as(t),O.retype(((...r)=>{let n;try{n=this(...r)}catch(n){if(!e||_.matches(n,e))return t(...r,n);throw n}return void 0===n?t(...r):n}),this)}which(t=t=>void 0!==t,e=O.WHICH_ERROR){return O.retype(O.which(this,t,e),this)}static which(t,e=t=>void 0!==t,r=void 0){return O.as(((...n)=>{const s=t(...n);if(e(s,...n))return s;if(void 0!==r)throw r}))}when(t,e,r,n=void 0,s=!0){return E.when(t,this,e,r,n,s)}match(...t){return O.retype(O.match(this,...t),this)}static match(...t){const e=t.length<2?e=>[e,t[0](e)]:e=>t.map((t=>t(e)));return O.as(e)}each(t){return O.retype(((...e)=>x.as(this(...e)).which().sthen(t).which().else()),this)}static each(...t){return O.as((e=>{const r=e instanceof b?e:b.of(e);return r.length>t.length?x.of():r.across(x.as(O.as(t[r.length-1])(r.last)).which()).which()}))}self(...t){return O.retype(O.self(this,...t),this)}static self(t,...e){let r;if(0===e.length)return r=e=>e.across(x.as(t(e.last)).which().toArray()),O.as(r);if("number"!=typeof e[0]){const[r,n]=e;return O.nominal(t,r,n)}if(2===e.length){const[r,n]=e;return O.partial(t,r,n)}return E.self(t,...e)}static partial(t,e,r){return O.as(((...n)=>t(...n.slice(0,e),r,...n.slice(e))))}static nominal(t,e,r){let n;return n=void 0===e?(...e)=>{const n=t(...e);if(void 0===n)return;const s={};return s[r]=n,s}:n=>{const s=x.as("string"==typeof e?[e]:e).sthen((t=>"string"==typeof t?n[t]:t)).toArray(),i=("string"==typeof t?n[t]:t)(...s);return void 0!==r?(n[r]=i,n):i},O.as(n)}}class x{[Symbol.iterator](){throw"abstract method!"}static as(t){if(void 0===t)return x.of();if(t instanceof x)return t;if(t[Symbol.iterator]){const e=new x;return e[Symbol.iterator]=t[Symbol.iterator].bind(t),e}{const e=new x;return e[Symbol.iterator]=function*(){yield t},e}}static of(...t){const e=new x;return e[Symbol.iterator]=function*(){for(const e of t)yield e},e}static along(t,e){const r=new x;return r[Symbol.iterator]=function*(){let r=t;for(;r;)yield r,r=e(r)},r}toArray(){return Array.from(this)}equals(t){return x.equal(this,t)}static equal(t,e){if("string"==typeof t||!x.isIterable(t)||"string"==typeof e||!x.isIterable(e))return t===e;{const r=t[Symbol.iterator](),n=e[Symbol.iterator]();for(;;){const t=r.next(),e=n.next();if(t.done||e.done)return t.done===e.done;if(!x.equal(t.value,e.value))return!1}}}static isIterable(t){return null!=t&&"function"==typeof t[Symbol.iterator]}if(t=t=>void 0!==t){return x.if(this,t)}static if(t,e=t=>void 0!==t){return x.which(t,e)}sthen(t){return x.sthen(this,t)}static sthen(t,e){const r=new x;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)yield e(n,r++)},r}else(t=void 0){return void 0===t?x.else(this):x.else(x.of(this,x.as(t)))}static else(t){const e=new x;return e[Symbol.iterator]=function*(){for(let e of t)if(e[Symbol.iterator])for(let t of e)yield t;else yield e},e}which(t=t=>void 0!==t){return x.which(this,t)}static which(t,e=t=>void 0!==t){const r=new x;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)e(n,r++)&&(yield n)},r}when(t,e=!0,r=e){return x.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},g.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const s=new x;return s[Symbol.iterator]=r?function*(){let r=0,s=!1;for(let i of t)s?yield i:e(i,r)&&(s=!0,n&&(yield i)),r++}:function*(){let r=0,s=!1;for(let i of t){if(s)break;e(i,r)?(s=!0,n&&(yield i)):yield i,r++}},s}match(t=void 0){return void 0===t?x.match(...this):x.match(this,x.as(t))}static match(...t){const e=new x;return e[Symbol.iterator]=function*(){const e=t.map((t=>t[Symbol.iterator]()));for(;;){const t=e.map((t=>t.next()));if(t.some((t=>t.done)))break;yield t.map((t=>t.value))}},e}each(t=void 0){if(void 0===t)return x.each(...this);const e=this,r=new x;return r[Symbol.iterator]=function*(){for(let r of e)for(let e of x.as(t))yield[r,e]},r}static each(...t){return t=t.map((t=>t[Symbol.iterator]?t:[t])),O.as((e=>e.length<t.length?e.across(t[e.length]):x.of()))}self(){return x.self(this)}static self(t){const e=new x;return e[Symbol.iterator]=function*(){for(;;)yield t},e}what(t=void 0,e=void 0){return x.what(this,t,e)}static what(t,e,r){if(e){void 0===r&&(r=x.what(t),t=x.when(t,1));for(let n of t)r=e(r,n);return r}for(let e of t)return e}}x.NATURAL=new x,x.NATURAL[Symbol.iterator]=function*(){let t=0;for(;;)yield t++};class S extends o{_what;constructor(t,e=1/0,r=100,n=2,s=1/0){if(super(),"function"!=typeof t)throw new TypeError("Ostinato requires a function as the refrain.");this._what=E.as(t).self(e,r,n,s)}play(){return this._what?.stopped&&(this._what.stopped=!1),this._what?.(),super.play(),this}pause(){return this._what&&(this._what.stopped=!0),super.pause(),this}}class I extends o{endTime;exit;timeout;constructor(t,e=!0){super(),this.endTime=t,this.exit=e,this.timeout=void 0}ttl(t){return this.endTime=Date.now()+t,this}get ttl(){return Math.max(0,this.endTime-Date.now())}play(){if(!this.playing){const t=Math.max(0,this.endTime-Date.now());this.timeout=setTimeout((()=>this.handleExpiration()),t),super.play()}return this}handleExpiration(){this.emit("ticket-expired",this),this.pause(),this.exit&&this.ensemble?.remove(this.name)}pause(){return this.playing&&(clearTimeout(this.timeout),this.timeout=void 0,super.pause()),this}}class T extends c{constructor(){super(),this.add("cues",new c).add("ostinatos",new c).add("tickets",new c)}get cues(){return this.get("cues")}get ostinatos(){return this.get("ostinatos")}get tickets(){return this.get("tickets")}cue(t,e,r,n,s){return this.cues.add(t,new h(e,r,n,s)),this}ostinato(t,e,r=1/0,n=1e3,s=1,i=1/0){return this.ostinatos.add(t,new S(e,r,n,s,i)),this}ticket(t,e,r=!0){return this.tickets.add(t,new I(e,r)),this}}return n})()));